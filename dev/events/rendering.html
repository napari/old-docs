

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Asynchronous Rendering &mdash; napari 0.4.4.dev18+g1dc317d documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="API Reference" href="../api.html" />
    <link rel="prev" title="Performance Monitoring" href="perfmon.html" />
    <script async defer data-domain="napari.org" src="https://plausible.io/js/plausible.js"></script>
     

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> napari
          

          
            
            <img src="../_static/napari_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.4.4.dev18+g1dc317d
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../plugins/index.html">Plugins</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="event_loop.html">An Introduction to the Event Loop in napari</a></li>
<li class="toctree-l2"><a class="reference internal" href="threading.html">Multithreading in napari</a></li>
<li class="toctree-l2"><a class="reference internal" href="perfmon.html">Performance Monitoring</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Asynchronous Rendering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#napari-async">NAPARI_ASYNC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#time-series-data">Time-series Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-scale-images">Multi-scale Images</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#napari-octree">NAPARI_OCTREE</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#octree-visuals">Octree Visuals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#octree-rendering">Octree Rendering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#octree-configuration-file">Octree Configuration File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-loaders">Multiple Loaders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#future-work-compatibility-with-the-existing-image-class">Future Work: Compatibility with the existing Image class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#future-work-extending-textureatlas2d">Future Work: Extending TextureAtlas2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="#future-work-level-zero-only-octrees">Future Work: Level Zero Only Octrees</a></li>
<li class="toctree-l4"><a class="reference internal" href="#future-work-caching">Future Work: Caching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/index.html">Developer Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../explanations/index.html">Explanations</a></li>
<li class="toctree-l1"><a class="reference external" href="https://napari.org">Home</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/napari/napari">Source Code</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">napari</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Guides</a> &raquo;</li>
        
      <li>Asynchronous Rendering</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/events/rendering.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="asynchronous-rendering">
<span id="rendering"></span><h1>Asynchronous Rendering<a class="headerlink" href="#asynchronous-rendering" title="Permalink to this headline">¶</a></h1>
<p>As discussed in the explanations document on rendering, asynchronous
rendering is a feature that allows napari to stay usable and responsive
even when data is loading slowly. There are two experimental asynchronous
rendering features, they can be enabled using the environment variables
<code class="docutils literal notranslate"><span class="pre">NAPARI_ASYNC</span></code> and <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE</span></code>.</p>
<div class="section" id="napari-async">
<h2>NAPARI_ASYNC<a class="headerlink" href="#napari-async" title="Permalink to this headline">¶</a></h2>
<p>Running napari with <code class="docutils literal notranslate"><span class="pre">NAPARI_ASYNC=1</span></code> enables asynchronous rendering using
the existing <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class. The
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class will no longer call
<code class="docutils literal notranslate"><span class="pre">np.asarray()</span></code> in the GUI thread. We do this so that if <code class="docutils literal notranslate"><span class="pre">np.asarray()</span></code>
blocks on IO or a computation, the GUI thread will not block and the
framerate will not suffer.</p>
<p>To avoid blocking the GUI thread the
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class will load chunks using the
new <code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkLoader</span></code>
class. The
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkLoader</span></code> will
call <code class="docutils literal notranslate"><span class="pre">np.asarray()</span></code> in a worker thread. When the worker thread finishes
it will call <code class="xref py py-meth docutils literal notranslate"><span class="pre">on_chunk_loaded()</span></code> with
the loaded data. The next frame <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>
can display the new data.</p>
<div class="section" id="time-series-data">
<h3>Time-series Data<a class="headerlink" href="#time-series-data" title="Permalink to this headline">¶</a></h3>
<p>Without <code class="docutils literal notranslate"><span class="pre">NAPARI_ASYNC</span></code> napari will block when switching slices. Napari
will hang until the new slice has loaded. If the slice loads slowly enough
you might see the “spinning wheel of death” on a Mac indicating the process
is hung.</p>
<p>Asynchronous rendering allows the user to interrupt the loading of a slice
at any time. The user can freely move the slice slider. This is especially
nice for remote or slow-loading data.</p>
</div>
<div class="section" id="multi-scale-images">
<h3>Multi-scale Images<a class="headerlink" href="#multi-scale-images" title="Permalink to this headline">¶</a></h3>
<p>With today’s <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class there are no
tiles or chunks. Instead, whenever the camera is panned or zoomed napari
fetches all the data needed to draw the entire current canvas. This
actually works amazingly well with local data. Fetching the whole canvas of
data each time can be quite fast.</p>
<p>With remote or other high latency data, however, this method can be very
slow. Even if you pan only a tiny amount, napari has to fetch the whole
canvas worth of data, and you cannot interrupt the load to further adjust
the camera.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">NAPARI_ASYNC</span></code> overall performance is the same, but the advantage is
you can interrupt the load by moving the camera at any time. This is a nice
improvement, but working with slow-loading data is still slow. Most large
image viewers improve on this experience with chunks or tiles. With chunks
or tiles when the image is panned the existing tiles are translated and
re-used. Then the viewer only needs to fetch tiles which newly slid onto
the screen. This style of rendering what our <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE</span></code> flag
enables.</p>
</div>
</div>
<div class="section" id="napari-octree">
<h2>NAPARI_OCTREE<a class="headerlink" href="#napari-octree" title="Permalink to this headline">¶</a></h2>
<p>Set <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE=1</span></code> to use the experimental
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a> class
instead of the normal <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class. The
new <a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a>
class will use the same
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkLoader</span></code> that
<code class="docutils literal notranslate"><span class="pre">NAPARI_ASYNC</span></code> enables. In addition, <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE</span></code> will use the new
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>
instead of the Vispy <code class="docutils literal notranslate"><span class="pre">ImageVisual</span></code> class that napari’s
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class uses.</p>
<p>See <a class="reference internal" href="#octree-configuration-file">Octree Configuration File</a> for Octree configuration options.</p>
<div class="section" id="octree-visuals">
<h3>Octree Visuals<a class="headerlink" href="#octree-visuals" title="Permalink to this headline">¶</a></h3>
<p>The visual portion of Octree rendering is implemented by three classes:
<code class="xref py py-class docutils literal notranslate"><span class="pre">VispyTiledImageLayer</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>,
and <code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code>.</p>
<p>The first two classes are named “tiled image” rather than “octree” because
currently they do not know that they are rendering out of an octree. We did
this intentionally to keep the visuals simpler and more general. However,
the approach has some limitations, and we might later need to create a
subclass of
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>
which is Octree-specific, see <a class="reference internal" href="#future-work-extending-textureatlas2d">Future Work: Extending TextureAtlas2D</a>.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> class
is a subclass of the generic Vispy <code class="docutils literal notranslate"><span class="pre">Texture2D</span></code> class. Like <code class="docutils literal notranslate"><span class="pre">Texture2D</span></code>
the <code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> class
owns one texture. However
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> uses this
one texture as an “atlas” which can hold multiple tiles.</p>
<p>For example, by default
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> uses a
(4096, 4096) texture that stores 256 different (256, 256) pixel tiles.
Adding or remove a single tile from the full atlas texture is very fast.
Under the hood adding one tile calls <code class="docutils literal notranslate"><span class="pre">glTexSubImage2D()</span></code> which only
updates the data in that specific (256, 256) portion of the full texture.</p>
<p>Aside from the data transfer cost,
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> is also
fast because we do not have to modify the scene graph or rebuild any
shaders when a tile is added or removed. In an early version of tiled
rendering we created a new <code class="docutils literal notranslate"><span class="pre">ImageVisual</span></code> for every tile. This resulted in
scene graph changes and shader rebuilds. At the time the scene graph
changes were causing crashes with <cite>PyQt5</cite>, but the atlas approach is better
for multiple reasons, so even if that crash were fixed the atlas is a
better solution.</p>
</div>
<div class="section" id="octree-rendering">
<h3>Octree Rendering<a class="headerlink" href="#octree-rendering" title="Permalink to this headline">¶</a></h3>
<p>The interface between the visuals and the Octree is the
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a> method
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage.get_drawable_chunks" title="napari.layers.image.experimental.octree_image.OctreeImage.get_drawable_chunks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_drawable_chunks()</span></code></a>.
The method is called by the
<code class="xref py py-class docutils literal notranslate"><span class="pre">VispyTiledImageLayer</span></code>
method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_update_drawn_chunks()</span></code>
every frame so it can update which tiles are drawn.
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a> calls
the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_intersection()</span></code>
method on its
<code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeSlice</span></code> to get
an
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_intersection.OctreeIntersection" title="napari.layers.image.experimental.octree_intersection.OctreeIntersection"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeIntersection</span></code></a>
object which contains the “ideal chunks” that should be drawn for the
current camera position.</p>
<p>The ideal chunks are the chunks at the preferred level of detail, the level
of detail that best matches the current canvas resolution. Drawing chunks
which are more detailed that this will look fine, the graphics card will
downsample them to the screen resolution, but it’s not efficient to use
higher resolution chunks than are needed. Meanwhile drawing chunks that are
coarser than the ideal level will look blurry, but it’s much better than
drawing nothing.</p>
<p>The decision about what level of detail to use is made by the
<code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeLoader</span></code>
class and its method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_drawable_chunks()</span></code>.
There are many different approaches one could take here as far as what to
draw when. Today we are doing something reasonable but it could potentially
be improved. In addition to deciding what level of detail to draw for each
ideal chunk, the class initiates asynchronous loads with the
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkLoader</span></code> for
chunks it wants to draw in the future.</p>
<p>The loader will only use chunks from a higher resolution if they are
already being drawn. For example when zooming out. However, it will never
initiate loads on higher resolution chunks, since it’s better off loading
and drawing the ideal chunks.</p>
<p>The loader will load lower resolution chunks in some cases. Although this
can slightly delay when the ideal chunks are loaded, it’s a very quick way
to get reasonable looking “coverage” of the area of interest. Often data
from one or two levels up isn’t even that noticeably degraded. This table
shows how many ideal chunks are “covered” a chunk at a higher level:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Levels Above Ideal</p></td>
<td><p>Coverage</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>64</p></td>
</tr>
</tbody>
</table>
<p>Although data 3 levels above will be quite blurry, it’s pretty amazing you
can load one chunk and it will cover 64 ideal chunks. This is the heart of
the power of Octrees, Quadtrees or image pyramids.</p>
</div>
<div class="section" id="octree-configuration-file">
<h3>Octree Configuration File<a class="headerlink" href="#octree-configuration-file" title="Permalink to this headline">¶</a></h3>
<p>Setting <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE=1</span></code> enables Octree rendering with the default
configuration. To customize the configuration set <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE</span></code> to be
the path of a JSON config file, such as <code class="docutils literal notranslate"><span class="pre">NAPARI_OCTREE=/tmp/octree.json</span></code>.</p>
<p>See <code class="xref py py-data docutils literal notranslate"><span class="pre">DEFAULT_OCTREE_CONFIG</span></code> for the current
config file format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;loader_defaults&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;log_path&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;force_synchronous&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;num_workers&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="s2">&quot;use_processes&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;auto_sync_ms&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
        <span class="s2">&quot;delay_queue_ms&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;octree&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;enabled&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;tile_size&quot;</span><span class="p">:</span> <span class="mi">256</span><span class="p">,</span>
        <span class="s2">&quot;log_path&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;loaders&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_workers&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;delay_queue_ms&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">},</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_workers&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;delay_queue_ms&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">loader_defaults</span></code> key contains settings that will be used by the
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkLoader</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Setting</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log_path</span></code></p></td>
<td><p>Write <code class="docutils literal notranslate"><span class="pre">ChunkLoader</span></code> log file to this path. For debugging.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">force_synchronous</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">true</span></code> the <code class="docutils literal notranslate"><span class="pre">ChunkLoader</span></code> loads synchronously.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">num_workers</span></code></p></td>
<td><p>The number of worker threads or processes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">use_processes</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">true</span></code> use worker processes instead of threads.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">auto_async_ms</span></code></p></td>
<td><p>Switch to synchronous if loads are faster than this.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">delay_queue_ms</span></code></p></td>
<td><p>Delay loads by this much.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">num_workers</span></code></p></td>
<td><p>The number of worker threads or processes.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">octree</span></code> key contains these settings:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Setting</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">enabled</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">false</span></code> then use the old <cite>Image</cite> class.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tile_size</span></code></p></td>
<td><p>Size of render tiles to use for rending.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log_path</span></code></p></td>
<td><p>Octree specific log file for debugging.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">loaders</span></code></p></td>
<td><p>Optional custom loaders, see below.</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">loaders</span></code> key lets you define and configure multiple
<code class="xref py py-class docutils literal notranslate"><span class="pre">LoaderPool</span></code> pools. The
key of each loader is the level relative to the ideal level. In the above
example configuration we define two loaders. The first with key <code class="docutils literal notranslate"><span class="pre">0</span></code> is for
loading chunks at the ideal level or one above. While the second with key
<code class="docutils literal notranslate"><span class="pre">2</span></code> will load chunks two above the ideal level or higher.</p>
<p>Each loader uses the <code class="docutils literal notranslate"><span class="pre">loader_defaults</span></code> but you can override the
<code class="docutils literal notranslate"><span class="pre">num_workers</span></code>, <code class="docutils literal notranslate"><span class="pre">auto_sync_ms</span></code> and <code class="docutils literal notranslate"><span class="pre">delay_queue_ms</span></code> values in
each loader defined in <code class="docutils literal notranslate"><span class="pre">loaders</span></code>.</p>
</div>
<div class="section" id="multiple-loaders">
<h3>Multiple Loaders<a class="headerlink" href="#multiple-loaders" title="Permalink to this headline">¶</a></h3>
<p>We allow multiple loaders to improve loading performance. There are a lot
of different strategies one could use when loading chunks. For example,
we tend to load chunks at a higher level prior to loading the chunks
at the ideal level. This gets “coverage” on the screen quickly, and then
the data can be refined by loading the ideal chunks.</p>
<p>One consideration is during rapid movement of the camera it’s easy to clog
up the loader pool with workers loading chunks that have already moved out
of view. The
<code class="xref py py-class docutils literal notranslate"><span class="pre">DelayQueue</span></code> was
created to help with this problem.</p>
<p>While we can’t cancel a load if a worker as started working on it, we can
trivially cancel loads that are still in our delay queue. If the chunk goes
out of view, we cancel the load. If the user pauses for a bit, we initiate
the loads.</p>
<p>With multiple loaders we can delay the ideal chunks, but we can configure
zero delay for the higher levels. A single chunk from two levels up will
cover 16 ideal chunks. So immediately loading them is a good way to get
data on the screen quickly. When the camera stops moving the
<code class="xref py py-class docutils literal notranslate"><span class="pre">LoaderPool</span></code> for the
ideal layer will often be empty. So all of those workers can immediately
start loading the ideal chunks.</p>
<p>The ability to have multiple loaders was only recently added. We still need
to experiment to figure out the best configuration. And figure out how that
configuration needs to vary based on the latency of the data or other
considerations.</p>
</div>
<div class="section" id="future-work-compatibility-with-the-existing-image-class">
<h3>Future Work: Compatibility with the existing Image class<a class="headerlink" href="#future-work-compatibility-with-the-existing-image-class" title="Permalink to this headline">¶</a></h3>
<p>The focus for initial Octree development was Octree-specific behaviors and
infrastructure. Loading chunks asynchronously and rendering them as
individual tiles. One question we wanted to answer was will a Python/Vispy
implementation of Octree rendering be performant enough? Because if not, we
might need a totally different approach. It’s not been fully proven out,
but it seems like the performance will be good enough, so the next step is
full compatibility with the existing
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class.</p>
<p>The <a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a>
class is derived from <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a>, while
<code class="xref py py-class docutils literal notranslate"><span class="pre">VispyTiledImageLayer</span></code>
is derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">VispyImageLayer</span></code>,
and
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code> is
derived from the regular Vispy <code class="docutils literal notranslate"><span class="pre">ImageVisual</span></code> class. To bring full
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> capability to
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a> in most
cases we just need to duplicate what those base classes are doing, but do
it on a per-tile bases. Since there is no full image for them to operate
on. This might involve chaining to the base class or it could mean
duplicating that functionality somehow in the derived class.</p>
<p>Some <a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> functionality that needs to
be duplicated in Octree code:</p>
<div class="section" id="contrast-limits-and-color-transforms">
<h4>Contrast Limits and Color Transforms<a class="headerlink" href="#contrast-limits-and-color-transforms" title="Permalink to this headline">¶</a></h4>
<p>The contrast limit code in Vispy’s <code class="docutils literal notranslate"><span class="pre">ImageVisual</span></code> needs to be moved into
the tiled visual’s
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_build_texture()</span></code>.
Instead operating on <code class="docutils literal notranslate"><span class="pre">self.data</span></code> it needs to transform tile’s which are newly
being added to the visual. The color transform similarly needs to be per-tile.</p>
</div>
<div class="section" id="blending-and-opacity">
<h4>Blending and Opacity<a class="headerlink" href="#blending-and-opacity" title="Permalink to this headline">¶</a></h4>
<p>It might be hard to get opacity working correctly for tiles where loads are
in progress. The way
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>
works today is the
<code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeLoader</span></code>
potentially passes the visual tiles of various sizes, from different levels
of the Octree. The tiles are rendered on top of each other from largest
(coarsest level) to smallest (finest level). This is a nice trick so that
bigger tiles to provide “coverage” for an area, while the smaller tiles add
detail only where that data has been loaded.</p>
<p>However, this breaks blending and opacity. We draw multiple tiles on top of
each other, so the image is blending with itself. One solution which is
kind of a big change is keep
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>
for the generic “tiled” case, but introduce a new <code class="docutils literal notranslate"><span class="pre">OctreeVisual</span></code> that
knows about the Octree. It can walk up and down the Octree chopping up
larger tiles to make sure we do not render anything on top of anything
else.</p>
<p>Until we do that, we could punt on making things look correct while loads
are in progress. We could even highly the fact that a tile has not been
fully loaded. Purposely make them look different until the data is fully
loaded. Aside from blending this would address a common complaint with
tiled image viewers: you often can’t tell if the data is still being
loaded. This could be a big issue for scientific uses, you don’t want
people drawing the wrong conclusions from the data.</p>
</div>
<div class="section" id="time-series-multiscale">
<h4>Time-series Multiscale<a class="headerlink" href="#time-series-multiscale" title="Permalink to this headline">¶</a></h4>
<p>To make time-series multiscale work should not be too hard. We just need to
correctly create a new
<code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeSlice</span></code> every
time the slice changes.</p>
<p>The challenge will probably be performance. For starters we probably need
to stop creating the “extra” downsampled levels, as described in <a class="reference internal" href="#future-work-extending-textureatlas2d">Future
Work: Extending TextureAtlas2D</a>. We need to make sure constructing and
tearing down the Octree is fast enough, and make sure loads for the
previous slices are canceled and everything is cleaned up.</p>
</div>
</div>
<div class="section" id="future-work-extending-textureatlas2d">
<h3>Future Work: Extending TextureAtlas2D<a class="headerlink" href="#future-work-extending-textureatlas2d" title="Permalink to this headline">¶</a></h3>
<p>We could improve our
<code class="xref py py-class docutils literal notranslate"><span class="pre">TextureAtlas2D</span></code> class in
a number of ways:</p>
<ol class="arabic simple">
<li><p>Support setting the atlas’s full texture size on the fly.</p></li>
<li><p>Support setting the atlas’s tile size on the fly.</p></li>
<li><p>Support a mix of tiles sizes in one atlas.</p></li>
<li><p>Allow an atlas to have more than one backing texture.</p></li>
</ol>
<p>One reason to consider these changes is so we could support “large tiles”
in certain cases. Often the coarsest level of multi-scale data “in the
wild” is much bigger than one of our (256, 256) tiles. Today we solve that
by creating additional Octree levels, downsampling the data until the
coarsest level fits within a single tile.</p>
<p>If we could support multiple tiles sizes and multiple backing textures, we
could potentially have “interior tiles” which were small, but then allow
large root tiles. Graphics cards can handle pretty big textures. A layer
that’s (100000, 100000) obviously needs to be broken into tiles, b¡ut a
layer that’s (4096, 4096) really does not need to be broken into tiles.
That could be a single large tile.</p>
<p>Long term it would be nice if we did not have to support two image classes:
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> and
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a>.
Maintaining two code paths and two sets of visuals will become tiresome and
lead to discrepancies and bugs.</p>
<p>Instead, it would be nice if
<a class="reference internal" href="../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage" title="napari.layers.image.experimental.octree_image.OctreeImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctreeImage</span></code></a> became
the only image class. One image class to rule them all. For that to happen,
though, we need to render small images just as efficiently as the
<a class="reference internal" href="../api/napari.layers.image.html#napari.layers.image.image.Image" title="napari.layers.image.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class does today. We do not want
Octree rendering to worsen cases which work well today. To keep today’s
performance for smaller images we probably need to add support for variable
size tiles.</p>
</div>
<div class="section" id="future-work-level-zero-only-octrees">
<h3>Future Work: Level Zero Only Octrees<a class="headerlink" href="#future-work-level-zero-only-octrees" title="Permalink to this headline">¶</a></h3>
<p>In issue <a class="reference external" href="https://github.com/napari/napari/issues/1300">#1300</a> it takes
1500ms to switch slices. There we are rendering a (16384, 16384) image that
is entirely in RAM. The delay is not from loading into RAM, it’s already in
RAM, the delay is from transferring all that data to VRAM in one big gulp.</p>
<p>The image is not a multi-scale image. So can we turn it into a muli-scale
image? Generally we’ve found downsampling to create multi-scale image
layers is slow. So the question is how can we draw this large image without
hanging? One idea is we could create an Octree that only has a level zero
and no downsampled levels.</p>
<p>This is an option because chopping up a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array into tiles is very
fast. This chopping up phase is really just creating a bunch of “views”
into the single existing array. So creating a level zero Octree should be
very fast. For there we can use our existing Octree code and our existing
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiledImageVisual</span></code>
to transfer over one tile at a time without hurting the frame rate.</p>
<p>The insight here is our Octree code is really two things, one is an Octree
but two is a tiled or chunked image, basically a flat image chopped into a
grid of tiles. How would this look to the user? With this approach
switching slices would be similar to panning and zooming a multiscale
Octree image, you’d see the new tiles loading in over time, but the
framerate would not tank, and you could switch slices at any time.</p>
</div>
<div class="section" id="future-work-caching">
<h3>Future Work: Caching<a class="headerlink" href="#future-work-caching" title="Permalink to this headline">¶</a></h3>
<p>Basically no work as gone into caching or memory management for Octree
data. It’s very likely there are leaks and extended usage will run out of
memory. This hasn’t been addressed because using Octree for long periods of
time is just now becoming possible.</p>
<p>One caching issue is figuring how to combine the <code class="docutils literal notranslate"><span class="pre">ChunkCache</span></code> with
Dasks’s built-in caching. We probably want to keep the <code class="docutils literal notranslate"><span class="pre">ChunkCache</span></code> for
rendering non-Dask arrays? But when using Dask, we defer to its cache? We
certainly don’t want to cache the data in both places.</p>
<p>Another issue is whether to cache <code class="docutils literal notranslate"><span class="pre">OctreeChunks</span></code> or tiles in the visual,
beyond just caching the raw data. If re-creating both is fast enough, the
simpler thing is evict them fully when a chunk falls out of view. And
re-create them if it comes back in view. It’s simplest to keep nothing but
what we are currently drawing.</p>
<p>However if that’s not fast enough, we could have a MRU cache of
<code class="docutils literal notranslate"><span class="pre">OctreeChunks</span></code> and tiles in VRAM, so that reviewing the same data is
nearly instant. This is adding complexity, but the performance might be
worth it.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="perfmon.html" class="btn btn-neutral float-left" title="Performance Monitoring" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, napari contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>