

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>napari.utils.event &mdash; napari 0.2.11+26.gf53d744 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> napari
          

          
            
            <img src="../../../_static/napari_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.11+26.gf53d744
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/napari/napari">Source</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">napari</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>napari.utils.event</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for napari.utils.event</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright (c) Vispy Development Team. All Rights Reserved.</span>
<span class="c1"># Distributed under the (new) BSD License. See LICENSE.txt for more info.</span>

<span class="c1"># # LICENSE.txt</span>
<span class="c1"># Vispy licensing terms</span>
<span class="c1"># ---------------------</span>

<span class="c1"># Vispy is licensed under the terms of the (new) BSD license:</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2013-2017, Vispy Development Team. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># * Redistributions of source code must retain the above copyright</span>
<span class="c1">#   notice, this list of conditions and the following disclaimer.</span>
<span class="c1"># * Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#   notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#   documentation and/or other materials provided with the distribution.</span>
<span class="c1"># * Neither the name of Vispy Development Team nor the names of its</span>
<span class="c1">#   contributors may be used to endorse or promote products</span>
<span class="c1">#   derived from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<span class="c1"># IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</span>
<span class="c1"># TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<span class="c1"># PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER</span>
<span class="c1"># OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<span class="c1"># EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<span class="c1"># PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<span class="c1"># PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="c1"># LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="c1"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Exceptions</span>
<span class="c1"># ----------</span>
<span class="c1">#</span>
<span class="c1"># The examples code in the examples directory can be considered public</span>
<span class="c1"># domain, unless otherwise indicated in the corresponding source file.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The event module implements the classes that make up the event system.</span>
<span class="sd">The Event class and its subclasses are used to represent &quot;stuff that happens&quot;.</span>
<span class="sd">The EventEmitter class provides an interface to connect to events and</span>
<span class="sd">to emit events. The EmitterGroup groups EventEmitter objects.</span>

<span class="sd">For more information see http://github.com/vispy/vispy/wiki/API_Events</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">vispy.util.logs</span> <span class="kn">import</span> <span class="n">logger</span><span class="p">,</span> <span class="n">_handle_exception</span>
<span class="kn">from</span> <span class="nn">vispy.ext.six</span> <span class="kn">import</span> <span class="n">string_types</span>


<div class="viewcode-block" id="Event"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.Event">[docs]</a><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class describing events that occur and can be reacted to with callbacks.</span>
<span class="sd">    Each event instance contains information about a single event that has</span>
<span class="sd">    occurred such as a key press, mouse motion, timer activation, etc.</span>

<span class="sd">    Subclasses: :class:`KeyEvent`, :class:`MouseEvent`, :class:`TouchEvent`,</span>
<span class="sd">    :class:`StylusEvent`</span>

<span class="sd">    The creation of events and passing of events to the appropriate callback</span>
<span class="sd">    functions is the responsibility of :class:`EventEmitter` instances.</span>

<span class="sd">    Note that each event object has an attribute for each of the input</span>
<span class="sd">    arguments listed below.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    type : str</span>
<span class="sd">       String indicating the event type (e.g. mouse_press, key_release)</span>
<span class="sd">    native : object (optional)</span>
<span class="sd">       The native GUI event object</span>
<span class="sd">    **kwargs : keyword arguments</span>
<span class="sd">        All extra keyword arguments become attributes of the event object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">native</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># stack of all sources this event has been emitted through</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Store args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_native</span> <span class="o">=</span> <span class="n">native</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The object that the event applies to (i.e. the source of the event).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; List of objects that the event applies to (i.e. are or have</span>
<span class="sd">        been a source of the event). Can contain multiple objects in case</span>
<span class="sd">        the event traverses a hierarchy of objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span>

    <span class="k">def</span> <span class="nf">_push_source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pop_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sources</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># No docstring; documeted in class docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">native</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># No docstring; documeted in class docstring</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_native</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">handled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This boolean property indicates whether the event has already been</span>
<span class="sd">        acted on by an event handler. Since many handlers may have access to</span>
<span class="sd">        the same events, it is recommended that each check whether the event</span>
<span class="sd">        has already been handled as well as set handled=True if it decides to</span>
<span class="sd">        act on the event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handled</span>

    <span class="nd">@handled</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">handled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handled</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This boolean property indicates whether the event will be delivered</span>
<span class="sd">        to event callbacks. If it is set to True, then no further callbacks</span>
<span class="sd">        will receive the event. When possible, it is recommended to use</span>
<span class="sd">        Event.handled rather than Event.blocked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span>

    <span class="nd">@blocked</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Try to generate a nice string representation of the event that</span>
        <span class="c1"># includes the interesting properties.</span>
        <span class="c1"># need to keep track of depth because it is</span>
        <span class="c1"># very difficult to avoid excessive recursion.</span>
        <span class="k">global</span> <span class="n">_event_repr_depth</span>
        <span class="n">_event_repr_depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_event_repr_depth</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;...&gt;&quot;</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># select only properties</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attrs</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">_event_repr_depth</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shorter string representation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span></div>


<span class="n">_event_repr_depth</span> <span class="o">=</span> <span class="mi">0</span>


<div class="viewcode-block" id="EventEmitter"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter">[docs]</a><span class="k">class</span> <span class="nc">EventEmitter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Encapsulates a list of event callbacks.</span>

<span class="sd">    Each instance of EventEmitter represents the source of a stream of similar</span>
<span class="sd">    events, such as mouse click events or timer activation events. For</span>
<span class="sd">    example, the following diagram shows the propagation of a mouse click</span>
<span class="sd">    event to the list of callbacks that are registered to listen for that</span>
<span class="sd">    event::</span>

<span class="sd">       User clicks    |Canvas creates</span>
<span class="sd">       mouse on       |MouseEvent:                |&#39;mouse_press&#39; EventEmitter:         |callbacks in sequence: # noqa</span>
<span class="sd">       Canvas         |                           |                                    |  # noqa</span>
<span class="sd">                   --&gt;|event = MouseEvent(...) --&gt;|Canvas.events.mouse_press(event) --&gt;|callback1(event)  # noqa</span>
<span class="sd">                      |                           |                                 --&gt;|callback2(event)  # noqa</span>
<span class="sd">                      |                           |                                 --&gt;|callback3(event)  # noqa</span>

<span class="sd">    Callback functions may be added or removed from an EventEmitter using</span>
<span class="sd">    :func:`connect() &lt;vispy.event.EventEmitter.connect&gt;` or</span>
<span class="sd">    :func:`disconnect() &lt;vispy.event.EventEmitter.disconnect&gt;`.</span>

<span class="sd">    Calling an instance of EventEmitter will cause each of its callbacks</span>
<span class="sd">    to be invoked in sequence. All callbacks are invoked with a single</span>
<span class="sd">    argument which will be an instance of :class:`Event &lt;vispy.event.Event&gt;`.</span>

<span class="sd">    EventEmitters are generally created by an EmitterGroup instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source : object</span>
<span class="sd">        The object that the generated events apply to. All emitted Events will</span>
<span class="sd">        have their .source property set to this value.</span>
<span class="sd">    type : str or None</span>
<span class="sd">        String indicating the event type (e.g. mouse_press, key_release)</span>
<span class="sd">    event_class : subclass of Event</span>
<span class="sd">        The class of events that this emitter will generate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_class</span><span class="o">=</span><span class="n">Event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># count number of times this emitter is blocked for each callback.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="c1"># used to detect emitter loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_args</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span>

        <span class="k">assert</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">event_class</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_class</span> <span class="o">=</span> <span class="n">event_class</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_callback_errors</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_callback_errors</span> <span class="o">=</span> <span class="s1">&#39;reminders&#39;</span>  <span class="c1"># &#39;reminders&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ignore_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether exceptions during callbacks will be caught by the emitter</span>

<span class="sd">        This allows it to continue invoking other callbacks if an error</span>
<span class="sd">        occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_callback_errors</span>

    <span class="nd">@ignore_callback_errors</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ignore_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_callback_errors</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">print_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a message and stack trace if a callback raises an exception</span>

<span class="sd">        Valid values are &quot;first&quot; (only show first instance), &quot;reminders&quot; (show</span>
<span class="sd">        complete first instance, then counts), &quot;always&quot; (always show full</span>
<span class="sd">        traceback), or &quot;never&quot;.</span>

<span class="sd">        This assumes ignore_callback_errors=True. These will be raised as</span>
<span class="sd">        warnings, so ensure that the vispy logging level is set to at</span>
<span class="sd">        least &quot;warning&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_callback_errors</span>

    <span class="nd">@print_callback_errors</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">print_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;reminders&#39;</span><span class="p">,</span> <span class="s1">&#39;always&#39;</span><span class="p">,</span> <span class="s1">&#39;never&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;print_callback_errors must be &quot;first&quot;, &#39;</span>
                <span class="s1">&#39;&quot;reminders&quot;, &quot;always&quot;, or &quot;never&quot;&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_callback_errors</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">callback_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of callback references&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of callbacks&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The object that events generated by this emitter apply to&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># get object behind weakref</span>

    <span class="nd">@source</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<div class="viewcode-block" id="EventEmitter.connect"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Connect this emitter to a new callback.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        callback : function | tuple</span>
<span class="sd">            *callback* may be either a callable object or a tuple</span>
<span class="sd">            (object, attr_name) where object.attr_name will point to a</span>
<span class="sd">            callable object. Note that only a weak reference to ``object``</span>
<span class="sd">            will be kept.</span>
<span class="sd">        ref : bool | str</span>
<span class="sd">            Reference used to identify the callback in ``before``/``after``.</span>
<span class="sd">            If True, the callback ref will automatically determined (see</span>
<span class="sd">            Notes). If False, the callback cannot be referred to by a string.</span>
<span class="sd">            If str, the given string will be used. Note that if ``ref``</span>
<span class="sd">            is not unique in ``callback_refs``, an error will be thrown.</span>
<span class="sd">        position : str</span>
<span class="sd">            If ``&#39;first&#39;``, the first eligible position is used (that</span>
<span class="sd">            meets the before and after criteria), ``&#39;last&#39;`` will use</span>
<span class="sd">            the last position.</span>
<span class="sd">        before : str | callback | list of str or callback | None</span>
<span class="sd">            List of callbacks that the current callback should precede.</span>
<span class="sd">            Can be None if no before-criteria should be used.</span>
<span class="sd">        after : str | callback | list of str or callback | None</span>
<span class="sd">            List of callbacks that the current callback should follow.</span>
<span class="sd">            Can be None if no after-criteria should be used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``ref=True``, the callback reference will be determined from:</span>

<span class="sd">            1. If ``callback`` is ``tuple``, the secend element in the tuple.</span>
<span class="sd">            2. The ``__name__`` attribute.</span>
<span class="sd">            3. The ``__class__.__name__`` attribute.</span>

<span class="sd">        The current list of callback refs can be obtained using</span>
<span class="sd">        ``event.callback_refs``. Callbacks can be referred to by either</span>
<span class="sd">        their string reference (if given), or by the actual callback that</span>
<span class="sd">        was attached (e.g., ``(canvas, &#39;swap_buffers&#39;)``).</span>

<span class="sd">        If the specified callback is already connected, then the request is</span>
<span class="sd">        ignored.</span>

<span class="sd">        If before is None and after is None (default), the new callback will</span>
<span class="sd">        be added to the beginning of the callback list. Thus the</span>
<span class="sd">        callback that is connected _last_ will be the _first_ to receive</span>
<span class="sd">        events from the emitter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span>
        <span class="n">callback_refs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_refs</span>

        <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_cb</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">in</span> <span class="n">callbacks</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># deal with the ref</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ref</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">callback</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>  <span class="c1"># function</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Method, or other</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;ref must be a bool or string&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ref</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ref &quot;</span><span class="si">%s</span><span class="s1">&quot; is not unique&#39;</span> <span class="o">%</span> <span class="n">ref</span><span class="p">)</span>

        <span class="c1"># positions</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;position must be &quot;first&quot; or &quot;last&quot;, not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">position</span>
            <span class="p">)</span>

        <span class="c1"># bounds</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># upper &amp; lower bnds (inclusive) of possible cb locs</span>
        <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">criteria</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">criteria</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">callback_refs</span><span class="p">)</span> <span class="k">if</span> <span class="n">ri</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criteria</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">criteria</span> <span class="o">=</span> <span class="p">[</span><span class="n">criteria</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">criteria</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">cn</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="n">cc</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">cn</span><span class="p">,</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">callback_refs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">)</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;criteria &quot;</span><span class="si">%s</span><span class="s1">&quot; is in the current &#39;</span>
                            <span class="s1">&#39;callback list </span><span class="si">%s</span><span class="s1"> times:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">criteria</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">callback_refs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ci</span>
                    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">callback_refs</span><span class="p">,</span> <span class="n">callbacks</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cc</span> <span class="ow">in</span> <span class="n">criteria</span> <span class="ow">or</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">criteria</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">ri</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">matches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># i.e., &quot;place before&quot; &lt; &quot;place after&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;cannot place callback before &quot;</span><span class="si">%s</span><span class="s1">&quot; &#39;</span>
                <span class="s1">&#39;and after &quot;</span><span class="si">%s</span><span class="s1">&quot; for callbacks: </span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">,</span> <span class="n">callback_refs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span> <span class="k">else</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># &#39;last&#39;</span>

        <span class="c1"># actually add the callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">callback</span>  <span class="c1"># allows connect to be used as a decorator</span></div>

<div class="viewcode-block" id="EventEmitter.disconnect"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.disconnect">[docs]</a>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disconnect a callback from this emitter.</span>

<span class="sd">        If no callback is specified, then *all* callbacks are removed.</span>
<span class="sd">        If the callback was not already connected, then the call does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_cb</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_callback_refs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_normalize_cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="c1"># dereference methods into a (self, method_name) pair so that we can</span>
        <span class="c1"># make the connection without making a strong reference to the</span>
        <span class="c1"># instance.</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="p">(</span><span class="n">callback</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,</span> <span class="n">callback</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># always use a weak ref</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">callback</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span>
        <span class="p">):</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">callback</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span> <span class="o">+</span> <span class="n">callback</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">callback</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; __call__(**kwargs)</span>
<span class="sd">        Invoke all callbacks for this emitter.</span>

<span class="sd">        Emit a new event object, created with the given keyword</span>
<span class="sd">        arguments, which must match with the input arguments of the</span>
<span class="sd">        corresponding event class. Note that the &#39;type&#39; argument is</span>
<span class="sd">        filled in by the emitter.</span>

<span class="sd">        Alternatively, the emitter can also be called with an Event</span>
<span class="sd">        instance as the only argument. In this case, the specified</span>
<span class="sd">        Event will be used rather than generating a new one. This allows</span>
<span class="sd">        customized Event instances to be emitted and also allows EventEmitters</span>
<span class="sd">        to be chained by connecting one directly to another.</span>

<span class="sd">        Note that the same Event instance is sent to all callbacks.</span>
<span class="sd">        This allows some level of communication between the callbacks</span>
<span class="sd">        (notably, via Event.handled) but also requires that callbacks</span>
<span class="sd">        be careful not to inadvertently modify the Event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a VERY highly used method; must be fast!</span>
        <span class="n">blocked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span>

        <span class="c1"># create / massage event as needed</span>
        <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add our source to the event; remove it after all callbacks have been</span>
        <span class="c1"># invoked.</span>
        <span class="n">event</span><span class="o">.</span><span class="n">_push_source</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">blocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># this is the same as self.blocked()</span>
                <span class="k">return</span> <span class="n">event</span>

            <span class="n">rem</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">[:]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
                    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">rem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">cb</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">blocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_invoke_callback</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">blocked</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># remove callbacks to dead objects</span>
            <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">rem</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">_pop_source</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Event source-stack mismatch.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">event</span>

    <span class="k">def</span> <span class="nf">_invoke_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cb</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">_handle_exception</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ignore_callback_errors</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_callback_errors</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">cb_event</span><span class="o">=</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">event</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># When emitting, this method is called to create or otherwise alter</span>
        <span class="c1"># an event before it is sent to callbacks. Subclasses may extend</span>
        <span class="c1"># this method to make custom modifications to the event.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Event</span><span class="p">):</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Ensure that the given event matches what we want to emit</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_class</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_class</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Event emitters can be called with an Event &quot;</span>
                <span class="s2">&quot;instance or with keyword arguments only.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">event</span>

<div class="viewcode-block" id="EventEmitter.blocked"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.blocked">[docs]</a>    <span class="k">def</span> <span class="nf">blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating whether the emitter is blocked for</span>
<span class="sd">        the given callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="EventEmitter.block"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.block">[docs]</a>    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block this emitter. Any attempts to emit an event while blocked</span>
<span class="sd">        will be silently ignored. If *callback* is given, then the emitter</span>
<span class="sd">        is only blocked for that specific callback.</span>

<span class="sd">        Calls to block are cumulative; the emitter must be unblocked the same</span>
<span class="sd">        number of times as it is blocked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="EventEmitter.unblock"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.unblock">[docs]</a>    <span class="k">def</span> <span class="nf">unblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Unblock this emitter. See :func:`event.EventEmitter.block`.</span>

<span class="sd">        Note: Use of ``unblock(None)`` only reverses the effect of</span>
<span class="sd">        ``block(None)``; it does not unblock callbacks that were explicitly</span>
<span class="sd">        blocked using ``block(callback)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot unblock </span><span class="si">%s</span><span class="s2"> for callback </span><span class="si">%s</span><span class="s2">; emitter &quot;</span>
                <span class="s2">&quot;was not previously blocked.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocked</span><span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span></div>

<div class="viewcode-block" id="EventEmitter.blocker"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventEmitter.blocker">[docs]</a>    <span class="k">def</span> <span class="nf">blocker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an EventBlocker to be used in &#39;with&#39; statements</span>

<span class="sd">           Notes</span>
<span class="sd">           -----</span>
<span class="sd">           For example, one could do::</span>

<span class="sd">               with emitter.blocker():</span>
<span class="sd">                   pass  # ..do stuff; no events will be emitted..</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EventBlocker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="WarningEmitter"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.WarningEmitter">[docs]</a><span class="k">class</span> <span class="nc">WarningEmitter</span><span class="p">(</span><span class="n">EventEmitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EventEmitter subclass used to allow deprecated events to be used with a</span>
<span class="sd">    warning message.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">EventEmitter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="WarningEmitter.connect"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.WarningEmitter.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EventEmitter</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_invoke_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EventEmitter</span><span class="o">.</span><span class="n">_invoke_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warned</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># don&#39;t warn about unimplemented connections</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">traceback</span><span class="o">.</span><span class="n">print_stack</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warned</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="EmitterGroup"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup">[docs]</a><span class="k">class</span> <span class="nc">EmitterGroup</span><span class="p">(</span><span class="n">EventEmitter</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;EmitterGroup instances manage a set of related</span>
<span class="sd">    :class:`EventEmitters &lt;vispy.event.EventEmitter&gt;`.</span>
<span class="sd">    Its primary purpose is to provide organization for objects</span>
<span class="sd">    that make use of multiple emitters and to reduce the boilerplate code</span>
<span class="sd">    needed to initialize those emitters with default connections.</span>

<span class="sd">    EmitterGroup instances are usually stored as an &#39;events&#39; attribute on</span>
<span class="sd">    objects that use multiple emitters. For example::</span>

<span class="sd">         EmitterGroup  EventEmitter</span>
<span class="sd">                 |       |</span>
<span class="sd">        Canvas.events.mouse_press</span>
<span class="sd">        Canvas.events.resized</span>
<span class="sd">        Canvas.events.key_press</span>

<span class="sd">    EmitterGroup is also a subclass of</span>
<span class="sd">    :class:`EventEmitters &lt;vispy.event.EventEmitter&gt;`,</span>
<span class="sd">    allowing it to emit its own</span>
<span class="sd">    events. Any callback that connects directly to the EmitterGroup will</span>
<span class="sd">    receive *all* of the events generated by the group&#39;s emitters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source : object</span>
<span class="sd">        The object that the generated events apply to.</span>
<span class="sd">    auto_connect : bool</span>
<span class="sd">        If *auto_connect* is True (default), then one connection will</span>
<span class="sd">        be made for each emitter that looks like</span>
<span class="sd">        :func:`emitter.connect((source, &#39;on_&#39; + event_name))</span>
<span class="sd">        &lt;vispy.event.EventEmitter.connect&gt;`.</span>
<span class="sd">        This provides a simple mechanism for automatically connecting a large</span>
<span class="sd">        group of emitters to default callbacks.</span>
<span class="sd">    emitters : keyword arguments</span>
<span class="sd">        See the :func:`add &lt;vispy.event.EmitterGroup.add&gt;` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auto_connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">emitters</span><span class="p">):</span>
        <span class="n">EventEmitter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">auto_connect</span> <span class="o">=</span> <span class="n">auto_connect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auto_connect_format</span> <span class="o">=</span> <span class="s2">&quot;on_</span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># whether the sub-emitters have been connected to the group:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_emitters_connected</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">**</span><span class="n">emitters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the emitter assigned to the specified name.</span>
<span class="sd">        Note that emitters may also be retrieved as an attribute of the</span>
<span class="sd">        EmitterGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">emitter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alias for EmitterGroup.add(name=emitter)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">emitter</span><span class="p">})</span>

<div class="viewcode-block" id="EmitterGroup.add"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto_connect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add one or more EventEmitter instances to this emitter group.</span>
<span class="sd">        Each keyword argument may be specified as either an EventEmitter</span>
<span class="sd">        instance or an Event subclass, in which case an EventEmitter will be</span>
<span class="sd">        generated automatically::</span>

<span class="sd">            # This statement:</span>
<span class="sd">            group.add(mouse_press=MouseEvent,</span>
<span class="sd">                      mouse_release=MouseEvent)</span>

<span class="sd">            # ..is equivalent to this statement:</span>
<span class="sd">            group.add(mouse_press=EventEmitter(group.source, &#39;mouse_press&#39;,</span>
<span class="sd">                                               MouseEvent),</span>
<span class="sd">                      mouse_release=EventEmitter(group.source, &#39;mouse_press&#39;,</span>
<span class="sd">                                                 MouseEvent))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">auto_connect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_connect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_connect</span>

        <span class="c1"># check all names before adding anything</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;EmitterGroup already has an emitter named &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The name &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot be used as an emitter; &quot;</span>
                    <span class="s2">&quot;it is already an attribute of EmitterGroup&quot;</span> <span class="o">%</span> <span class="n">name</span>
                <span class="p">)</span>

        <span class="c1"># add each emitter specified in the keyword arguments</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">emitter</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">emitter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">emitter</span> <span class="o">=</span> <span class="n">Event</span>

            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">emitter</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">emitter</span><span class="p">,</span> <span class="n">Event</span><span class="p">):</span>
                <span class="n">emitter</span> <span class="o">=</span> <span class="n">EventEmitter</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">event_class</span><span class="o">=</span><span class="n">emitter</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emitter</span><span class="p">,</span> <span class="n">EventEmitter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;Emitter must be specified as either an &#39;</span>
                    <span class="s1">&#39;EventEmitter instance or Event subclass. &#39;</span>
                    <span class="s1">&#39;(got </span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">emitter</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># give this emitter the same source as the group.</span>
            <span class="n">emitter</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">emitter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">emitter</span>

            <span class="k">if</span> <span class="n">auto_connect</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">emitter</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto_connect_format</span> <span class="o">%</span> <span class="n">name</span><span class="p">))</span>

            <span class="c1"># If emitters are connected to the group already, then this one</span>
            <span class="c1"># should be connected as well.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters_connected</span><span class="p">:</span>
                <span class="n">emitter</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">emitters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; List of current emitters in this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over the names of emitters in this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span>

<div class="viewcode-block" id="EmitterGroup.block_all"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup.block_all">[docs]</a>    <span class="k">def</span> <span class="nf">block_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Block all emitters in this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">em</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">em</span><span class="o">.</span><span class="n">block</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmitterGroup.unblock_all"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup.unblock_all">[docs]</a>    <span class="k">def</span> <span class="nf">unblock_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Unblock all emitters in this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unblock</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">em</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">em</span><span class="o">.</span><span class="n">unblock</span><span class="p">()</span></div>

<div class="viewcode-block" id="EmitterGroup.connect"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Connect the callback to the event group. The callback will receive</span>
<span class="sd">        events from *all* of the emitters in the group.</span>

<span class="sd">        See :func:`EventEmitter.connect() &lt;vispy.event.EventEmitter.connect&gt;`</span>
<span class="sd">        for arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_emitters</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EventEmitter</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="EmitterGroup.disconnect"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EmitterGroup.disconnect">[docs]</a>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Disconnect the callback from this group. See</span>
<span class="sd">        :func:`connect() &lt;vispy.event.EmitterGroup.connect&gt;` and</span>
<span class="sd">        :func:`EventEmitter.connect() &lt;vispy.event.EventEmitter.connect&gt;` for</span>
<span class="sd">        more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">EventEmitter</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connect_emitters</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">_connect_emitters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connect</span><span class="p">):</span>
        <span class="c1"># Connect/disconnect all sub-emitters from the group. This allows the</span>
        <span class="c1"># group to emit an event whenever _any_ of the sub-emitters emit,</span>
        <span class="c1"># while simultaneously eliminating the overhead if nobody is listening.</span>
        <span class="k">if</span> <span class="n">connect</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">emitter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">emitter</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">emitter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">emitter</span><span class="p">]</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_emitters_connected</span> <span class="o">=</span> <span class="n">connect</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ignore_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">EventEmitter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore_callback_errors</span>

    <span class="nd">@ignore_callback_errors</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ignore_callback_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore</span><span class="p">):</span>
        <span class="n">EventEmitter</span><span class="o">.</span><span class="n">ignore_callback_errors</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">emitter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_emitters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emitter</span><span class="p">,</span> <span class="n">EventEmitter</span><span class="p">):</span>
                <span class="n">emitter</span><span class="o">.</span><span class="n">ignore_callback_errors</span> <span class="o">=</span> <span class="n">ignore</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">emitter</span><span class="p">,</span> <span class="n">EmitterGroup</span><span class="p">):</span>
                <span class="n">emitter</span><span class="o">.</span><span class="n">ignore_callback_errors_all</span><span class="p">(</span><span class="n">ignore</span><span class="p">)</span></div>


<div class="viewcode-block" id="EventBlocker"><a class="viewcode-back" href="../../../api/napari.utils.html#napari.utils.event.EventBlocker">[docs]</a><span class="k">class</span> <span class="nc">EventBlocker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; Represents a block for an EventEmitter to be used in a context</span>
<span class="sd">    manager (i.e. &#39;with&#39; statement).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">unblock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, napari contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>