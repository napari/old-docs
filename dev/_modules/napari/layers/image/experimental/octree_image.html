

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>napari.layers.image.experimental.octree_image &mdash; napari 0.4.4.dev21+g679fd1d documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <script async defer data-domain="napari.org" src="https://plausible.io/js/plausible.js"></script>
     

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> napari
          

          
            
            <img src="../../../../../_static/napari_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.4.4.dev21+g679fd1d
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../events/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../releases.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developers/index.html">Developer Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../explanations/index.html">Explanations</a></li>
<li class="toctree-l1"><a class="reference external" href="https://napari.org">Home</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/napari/napari">Source Code</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">napari</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
      <li>napari.layers.image.experimental.octree_image</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for napari.layers.image.experimental.octree_image</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;OctreeImage class.</span>

<span class="sd">An eventual replacement for Image that combines single-scale and</span>
<span class="sd">chunked (tiled) multi-scale into one implementation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">....components.experimental.chunk</span> <span class="kn">import</span> <span class="n">ChunkRequest</span><span class="p">,</span> <span class="n">LayerRef</span>
<span class="kn">from</span> <span class="nn">....utils.events</span> <span class="kn">import</span> <span class="n">Event</span>
<span class="kn">from</span> <span class="nn">..image</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">._octree_slice</span> <span class="kn">import</span> <span class="n">OctreeSlice</span><span class="p">,</span> <span class="n">OctreeView</span>
<span class="kn">from</span> <span class="nn">.octree_chunk</span> <span class="kn">import</span> <span class="n">OctreeChunk</span>
<span class="kn">from</span> <span class="nn">.octree_intersection</span> <span class="kn">import</span> <span class="n">OctreeIntersection</span>
<span class="kn">from</span> <span class="nn">.octree_level</span> <span class="kn">import</span> <span class="n">OctreeLevelInfo</span>
<span class="kn">from</span> <span class="nn">.octree_util</span> <span class="kn">import</span> <span class="n">OctreeDisplayOptions</span><span class="p">,</span> <span class="n">OctreeMetadata</span>

<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;napari.octree.image&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="OctreeImage"><a class="viewcode-back" href="../../../../../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage">[docs]</a><span class="k">class</span> <span class="nc">OctreeImage</span><span class="p">(</span><span class="n">Image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Image layer rendered using an octree.</span>

<span class="sd">    Experimental variant of Image that renders using an octree. For 2D</span>
<span class="sd">    images the octree is really just a quadtree. For 3D volumes it will be</span>
<span class="sd">    a real octree. This class is intended to eventually replace the</span>
<span class="sd">    existing Image class.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The original Image class handled single-scale and multi-scale images,</span>
<span class="sd">    but they were handled quite differently. And its multi-scale did not</span>
<span class="sd">    use chunks or tiles. It worked well on local data, but was basically</span>
<span class="sd">    unusable for remote or high latency data.</span>

<span class="sd">    OctreeImage always uses chunk/tiles. Today those tiles are always</span>
<span class="sd">    &quot;small&quot;. However, as a special case, if an image is smaller than the</span>
<span class="sd">    max texture size, we could some day allow OctreeImage to set its tile</span>
<span class="sd">    size equal to that image size.</span>

<span class="sd">    At that point &quot;small&quot; images would be draw with a single texture,</span>
<span class="sd">    the same way the old Image class drew then. So it would be very</span>
<span class="sd">    efficient.</span>

<span class="sd">    But larger images would have multiple chunks/tiles and multiple levels.</span>
<span class="sd">    Unlike the original Image class multi-scale, the chunks/tiles mean we</span>
<span class="sd">    only have to incrementally load more data as the user pans and zooms.</span>

<span class="sd">    The goal is OctreeImage gets renamed to just Image and it efficiently</span>
<span class="sd">    handles images of any size. It make take a while to get there.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _view : OctreeView</span>
<span class="sd">        Describes a view frustum which implies what portion of the OctreeImage</span>
<span class="sd">        needs to be draw.</span>
<span class="sd">    _slice : OctreeSlice</span>
<span class="sd">        When _set_view_slice() is called we create a OctreeSlice()</span>
<span class="sd">        that&#39;s looking at some specific slice of the data.</span>
<span class="sd">    _display : OctreeDisplayOptions</span>
<span class="sd">        Settings for how we draw the octree, such as tile size.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">:</span> <span class="n">OctreeView</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">:</span> <span class="n">OctreeSlice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="p">:</span> <span class="n">OctreeIntersection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">OctreeDisplayOptions</span><span class="p">()</span>

        <span class="c1"># super().__init__ will call our _set_view_slice() which is kind</span>
        <span class="c1"># of annoying since we are aren&#39;t fully constructed yet.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Call after super().__init__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">octree_level</span><span class="o">=</span><span class="n">Event</span><span class="p">,</span> <span class="n">tile_size</span><span class="o">=</span><span class="n">Event</span><span class="p">)</span>

        <span class="c1"># TODO_OCTREE: this is hack that we assign OctreeDisplayOptions</span>
        <span class="c1"># this event after super().__init__(). Needs to be cleaned up.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="o">.</span><span class="n">loaded_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">loaded</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override Image._get_value(position).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># TODO_OCTREE: need to implement this.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Has the data for this layer been loaded yet.</span>

<span class="sd">        As far as the visual system is concerned we are always &quot;loaded&quot; in</span>
<span class="sd">        that we can always be drawn. Because our VispyTiledImageLayer can</span>
<span class="sd">        always be drawn. Even if no chunk/tiles are loaded yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Is this layer completely empty so it can&#39;t be drawn.</span>

<span class="sd">        As with self.loaded, we are never really empty. Our VispyTiledImageLayer</span>
<span class="sd">        can always be drawn. Even if there is nothing to draw.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_update_thumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO_OCTREE: replace Image._update_thumbnail with nothing for</span>
        <span class="c1"># the moment until we decide how to do thumbnail.</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_data_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Viewable image for the current slice. (compatibility)&quot;&quot;&quot;</span>
        <span class="c1"># Override Image._data_view</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># fake: does octree need this?</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OctreeDisplayOptions</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The display options for this octree image layer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the edge length of single tile, for example 256.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The edge length of a single tile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="o">.</span><span class="n">tile_size</span>

    <span class="nd">@tile_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tile_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set new tile_size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile_size : int</span>
<span class="sd">            The new tile size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="o">.</span><span class="n">tile_size</span> <span class="o">=</span> <span class="n">tile_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">tile_size</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For now must explicitly delete it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># Creates a new slice.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tile_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the shape of a single tile, for example 256x256x3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The shape of a single tile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiscale</span><span class="p">:</span>
            <span class="n">init_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">tile_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span><span class="p">:</span>
            <span class="c1"># Add the color dimension (usually 3 or 4)</span>
            <span class="n">tile_shape</span> <span class="o">+=</span> <span class="p">(</span><span class="n">init_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>

        <span class="k">return</span> <span class="n">tile_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OctreeMetadata</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Information about the current octree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OctreeMetadata</span>
<span class="sd">            Octree dimensions and other info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">meta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">octree_level_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OctreeLevelInfo</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Information about the current level of the current octree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OctreeLevelInfo</span>
<span class="sd">            Information about the current octree level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">octree_level_info</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Current level of multiscale.</span>

<span class="sd">        The base full resolution image is level 0. The highest and coarsest</span>
<span class="sd">        level usually contains only a single tile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_level</span>

    <span class="nd">@data_level</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the octree level we should be displaying.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Display this octree level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_level</span> <span class="o">==</span> <span class="n">level</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># It didn&#39;t change.</span>

        <span class="c1"># Quickly check for less than 0. We can&#39;t check for a level</span>
        <span class="c1"># that&#39;s too high because the Octree might have extended levels?</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Octree level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> is negative.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_level</span> <span class="o">=</span> <span class="n">level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">octree_level</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This will raise if the level is too high.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">octree_level</span> <span class="o">=</span> <span class="n">level</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">loaded</span><span class="p">()</span>  <span class="c1"># redraw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_octree_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the total number of octree levels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of octree levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Multiscale</span>

    <span class="k">def</span> <span class="nf">_new_empty_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the current slice to an empty image.</span>

<span class="sd">        Overides Image._new_empty_slice() and does nothing because we don&#39;t</span>
<span class="sd">        need an empty slice. We create self._slice when</span>
<span class="sd">        self._set_view_slice() is called.</span>

<span class="sd">        The empty slice was needed to satisfy the old VispyImageLayer that</span>
<span class="sd">        used a single ImageVisual. But OctreeImage is drawn with</span>
<span class="sd">        VispyTiledImageVisual. It does not need an empty image. It gets</span>
<span class="sd">        chunks from our self.drawable_chunks property, and it will just draw</span>
<span class="sd">        nothing if that returns an empty list.</span>

<span class="sd">        When OctreeImage become the only image class, this can go away.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OctreeImage.get_drawable_chunks"><a class="viewcode-back" href="../../../../../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage.get_drawable_chunks">[docs]</a>    <span class="k">def</span> <span class="nf">get_drawable_chunks</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">drawn_set</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">OctreeChunk</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">OctreeChunk</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the chunks in the current slice which are drawable.</span>

<span class="sd">        The visual calls this and then draws what we send it. The call to</span>
<span class="sd">        get_intersection() will chose the appropriate level of the octree</span>
<span class="sd">        to intersect, and then return all the chunks within the</span>
<span class="sd">        intersection with that level.</span>

<span class="sd">        These are the &quot;ideal&quot; chunks because they are at the level whose</span>
<span class="sd">        resolution best matches the current screen resolution.</span>

<span class="sd">        Drawing chunks at a lower level than this will work fine, but it&#39;s</span>
<span class="sd">        a waste in that those chunks will just be downsampled by the card.</span>
<span class="sd">        You won&#39;t see any &quot;extra&quot; resolution at all. The card can do this</span>
<span class="sd">        super fast, so the issue not such much speed as it is RAM and VRAM.</span>

<span class="sd">        In the opposite direction, drawing chunks from a higher, the number</span>
<span class="sd">        of chunks and storage goes down quickly. The only issue there is</span>
<span class="sd">        visual quality, the imagery might look blurry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        drawn_set : Set[OctreeChunk]</span>
<span class="sd">            The chunks that are currently being drawn by the visual.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[OctreeChunk]</span>
<span class="sd">            The drawable chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_drawable_chunks: No slice or view&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># There is nothing to draw.</span>

        <span class="c1"># TODO_OCTREE: Make this a config option, maybe different</span>
        <span class="c1"># expansion_factor each level above the ideal level?</span>
        <span class="n">expansion_factor</span> <span class="o">=</span> <span class="mf">1.1</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">expansion_factor</span><span class="p">)</span>

        <span class="c1"># Get the current intersection and save it off.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">get_intersection</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_drawable_chunks: Intersection is empty&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># No chunks to draw.</span>

        <span class="c1"># Get the ideal chunks. These are the chunks at the preferred</span>
        <span class="c1"># resolution. The ones we ideally want to draw once they are in RAM</span>
        <span class="c1"># and in VRAM. When all loading is done, we will draw all the ideal</span>
        <span class="c1"># chunks.</span>
        <span class="n">ideal_chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="o">.</span><span class="n">get_chunks</span><span class="p">(</span><span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ideal_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">level_index</span>

        <span class="c1"># log_chunks(&quot;ideal_chunks&quot;, ideal_chunks)</span>

        <span class="c1"># If we are seting the data level level automatically, then update</span>
        <span class="c1"># our level to match what was chosen for the intersection.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="o">.</span><span class="n">auto_level</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_level</span> <span class="o">=</span> <span class="n">ideal_level</span>

        <span class="c1"># The loader will initiate loads on any ideal chunks which are not</span>
        <span class="c1"># yet in memory. And it will return the chunks we should draw. The</span>
        <span class="c1"># chunks we should draw might be ideal chunks, if they are in</span>
        <span class="c1"># memory, but they also might be chunks from higher or lower levels</span>
        <span class="c1"># in the octree. In general we try to draw &quot;cover the view&quot; with</span>
        <span class="c1"># the &quot;best available&quot; data.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">get_drawable_chunks</span><span class="p">(</span>
            <span class="n">drawn_set</span><span class="p">,</span> <span class="n">ideal_chunks</span><span class="p">,</span> <span class="n">ideal_level</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_update_draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">,</span> <span class="n">corner_pixels</span><span class="p">,</span> <span class="n">shape_threshold</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Override Layer._update_draw completely.</span>

<span class="sd">        The base Layer._update_draw does stuff for the legacy multi-scale</span>
<span class="sd">        that we don&#39;t want. And it calls refresh() which we don&#39;t need.</span>

<span class="sd">        We create our OctreeView() here which has the corners in it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale_factor : float</span>
<span class="sd">            Scale factor going from canvas to world coordinates.</span>
<span class="sd">        corner_pixels : array</span>
<span class="sd">            Coordinates of the top-left and bottom-right canvas pixels in the</span>
<span class="sd">            world coordinates.</span>
<span class="sd">        shape_threshold : tuple</span>
<span class="sd">            Requested shape of field of view in data coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute our 2D corners from the incoming n-d corner_pixels</span>
        <span class="n">data_corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">simplified</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">corner_pixels</span><span class="p">)</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">data_corners</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims_displayed</span><span class="p">]</span>

        <span class="c1"># Update our self._view to to capture the state of things right</span>
        <span class="c1"># before we are drawn. Our self._view will used by our</span>
        <span class="c1"># drawable_chunks() method.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_view</span> <span class="o">=</span> <span class="n">OctreeView</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">shape_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>

<div class="viewcode-block" id="OctreeImage.get_intersection"><a class="viewcode-back" href="../../../../../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage.get_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">get_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">OctreeIntersection</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The the interesection between the current view and the octree.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OctreeIntersection</span>
<span class="sd">            The intersection between the current view and the octree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">get_intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_view</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_outside_data_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if requested slice is outside of data range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if requested slice is outside data range.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extent_data</span>
        <span class="n">not_disp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims_not_displayed</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span>
                <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">not_disp</span><span class="p">],</span>
                <span class="p">[</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">not_disp</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span>
                <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">not_disp</span><span class="p">],</span>
                <span class="p">[</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">not_disp</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_view_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set the view given the indices to slice with.</span>

<span class="sd">        This replaces Image._set_view_slice() entirely. The hope is eventually</span>
<span class="sd">        this class OctreeImage becomes Image. And the non-tiled multiscale</span>
<span class="sd">        logic in Image._set_view_slice goes away entirely.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For now bail out so we don&#39;t nuke an existing slice which</span>
            <span class="c1"># contains an existing octree. Soon we&#39;ll need to figure out</span>
            <span class="c1"># if we are really changing slices (and need a new octree).</span>
            <span class="k">return</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice_indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outside_data_range</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Indices to get at the data we are currently viewing.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice_indices</span><span class="p">()</span>

        <span class="c1"># TODO_OCTREE: easier way to do this?</span>
        <span class="n">base_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">base_shape_2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims_displayed</span><span class="p">]</span>

        <span class="n">layer_ref</span> <span class="o">=</span> <span class="n">LayerRef</span><span class="o">.</span><span class="n">from_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="n">OctreeMetadata</span><span class="p">(</span>
            <span class="n">layer_ref</span><span class="p">,</span> <span class="n">base_shape_2d</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="o">.</span><span class="n">tile_size</span>
        <span class="p">)</span>

        <span class="c1"># OctreeSlice wants all the levels, but only the dimensions</span>
        <span class="c1"># of each level that we are currently viewing.</span>
        <span class="n">slice_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">level_data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">level_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="n">layer_ref</span> <span class="o">=</span> <span class="n">LayerRef</span><span class="o">.</span><span class="n">from_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Create the slice, it will create the actual Octree.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="o">=</span> <span class="n">OctreeSlice</span><span class="p">(</span>
            <span class="n">slice_data</span><span class="p">,</span>
            <span class="n">layer_ref</span><span class="p">,</span>
            <span class="n">meta</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_to_displayed</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_slice_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the slice indices including possible depth for RGB.&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice_indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>

        <span class="k">return</span> <span class="n">indices</span>

<div class="viewcode-block" id="OctreeImage.on_chunk_loaded"><a class="viewcode-back" href="../../../../../api/napari.layers.image.experimental.html#napari.layers.image.experimental.octree_image.OctreeImage.on_chunk_loaded">[docs]</a>    <span class="k">def</span> <span class="nf">on_chunk_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">ChunkRequest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;An asynchronous ChunkRequest was loaded.</span>

<span class="sd">        Override Image.on_chunk_loaded() fully.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        request : ChunkRequest</span>
<span class="sd">            This request was loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;on_chunk_loaded: load=</span><span class="si">%.3f</span><span class="s2">ms elapsed=</span><span class="si">%.3f</span><span class="s2">ms location = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">request</span><span class="o">.</span><span class="n">load_ms</span><span class="p">,</span>
            <span class="n">request</span><span class="o">.</span><span class="n">elapsed_ms</span><span class="p">,</span>
            <span class="n">request</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Pass it to the slice, it will insert the newly loaded data into</span>
        <span class="c1"># the OctreeChunk at the right location.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">on_chunk_loaded</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="c1"># Redraw with the new chunk.</span>
            <span class="c1"># TODO_OCTREE: Call this at most once per frame? It&#39;s a bad</span>
            <span class="c1"># idea to call it for every chunk?</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;on_chunk_loaded calling loaded()&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">loaded</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">remote_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Messages we should send to remote clients.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;tile_state&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="o">.</span><span class="n">tile_state</span><span class="p">,</span>
            <span class="s2">&quot;tile_config&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersection</span><span class="o">.</span><span class="n">tile_config</span><span class="p">,</span>
        <span class="p">}</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, napari contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>