

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>napari._vispy.volume &mdash; napari  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> napari
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../napari.html">napari package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">napari</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>napari._vispy.volume</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for napari._vispy.volume</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">vispy.scene.visuals</span> <span class="kn">import</span> <span class="n">Volume</span> <span class="k">as</span> <span class="n">BaseVolume</span>
<span class="kn">from</span> <span class="nn">vispy.visuals.shaders</span> <span class="kn">import</span> <span class="n">Function</span>

<span class="c1"># Vertex shader</span>
<span class="n">VERT_SHADER</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">attribute vec3 a_position;</span>
<span class="s2">// attribute vec3 a_texcoord;</span>
<span class="s2">uniform vec3 u_shape;</span>

<span class="s2">// varying vec3 v_texcoord;</span>
<span class="s2">varying vec3 v_position;</span>
<span class="s2">varying vec4 v_nearpos;</span>
<span class="s2">varying vec4 v_farpos;</span>

<span class="s2">void main() {</span>
<span class="s2">    // v_texcoord = a_texcoord;</span>
<span class="s2">    v_position = a_position;</span>

<span class="s2">    // Project local vertex coordinate to camera position. Then do a step</span>
<span class="s2">    // backward (in cam coords) and project back. Voila, we get our ray vector.</span>
<span class="s2">    vec4 pos_in_cam = $viewtransformf(vec4(v_position, 1));</span>

<span class="s2">    // intersection of ray and near clipping plane (z = -1 in clip coords)</span>
<span class="s2">    pos_in_cam.z = -pos_in_cam.w;</span>
<span class="s2">    v_nearpos = $viewtransformi(pos_in_cam);</span>

<span class="s2">    // intersection of ray and far clipping plane (z = +1 in clip coords)</span>
<span class="s2">    pos_in_cam.z = pos_in_cam.w;</span>
<span class="s2">    v_farpos = $viewtransformi(pos_in_cam);</span>

<span class="s2">    gl_Position = $transform(vec4(v_position, 1.0));</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

<span class="c1"># Fragment shader</span>
<span class="n">FRAG_SHADER</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">// uniforms</span>
<span class="s2">uniform $sampler_type u_volumetex;</span>
<span class="s2">uniform vec3 u_shape;</span>
<span class="s2">uniform float u_threshold;</span>
<span class="s2">uniform float u_relative_step_size;</span>

<span class="s2">//varyings</span>
<span class="s2">// varying vec3 v_texcoord;</span>
<span class="s2">varying vec3 v_position;</span>
<span class="s2">varying vec4 v_nearpos;</span>
<span class="s2">varying vec4 v_farpos;</span>

<span class="s2">// uniforms for lighting. Hard coded until we figure out how to do lights</span>
<span class="s2">const vec4 u_ambient = vec4(0.2, 0.2, 0.2, 1.0);</span>
<span class="s2">const vec4 u_diffuse = vec4(0.8, 0.2, 0.2, 1.0);</span>
<span class="s2">const vec4 u_specular = vec4(1.0, 1.0, 1.0, 1.0);</span>
<span class="s2">const float u_shininess = 40.0;</span>

<span class="s2">//varying vec3 lightDirs[1];</span>

<span class="s2">// global holding view direction in local coordinates</span>
<span class="s2">vec3 view_ray;</span>

<span class="s2">float rand(vec2 co)</span>
<span class="s2">{{</span>
<span class="s2">    // Create a pseudo-random number between 0 and 1.</span>
<span class="s2">    // http://stackoverflow.com/questions/4200224</span>
<span class="s2">    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);</span>
<span class="s2">}}</span>

<span class="s2">float colorToVal(vec4 color1)</span>
<span class="s2">{{</span>
<span class="s2">    return color1.g; // todo: why did I have this abstraction in visvis?</span>
<span class="s2">}}</span>

<span class="s2">vec4 calculateColor(vec4 betterColor, vec3 loc, vec3 step)</span>
<span class="s2">{{</span>
<span class="s2">    // Calculate color by incorporating lighting</span>
<span class="s2">    vec4 color1;</span>
<span class="s2">    vec4 color2;</span>

<span class="s2">    // View direction</span>
<span class="s2">    vec3 V = normalize(view_ray);</span>

<span class="s2">    // calculate normal vector from gradient</span>
<span class="s2">    vec3 N; // normal</span>
<span class="s2">    color1 = $sample( u_volumetex, loc+vec3(-step[0],0.0,0.0) );</span>
<span class="s2">    color2 = $sample( u_volumetex, loc+vec3(step[0],0.0,0.0) );</span>
<span class="s2">    N[0] = colorToVal(color1) - colorToVal(color2);</span>
<span class="s2">    betterColor = max(max(color1, color2),betterColor);</span>
<span class="s2">    color1 = $sample( u_volumetex, loc+vec3(0.0,-step[1],0.0) );</span>
<span class="s2">    color2 = $sample( u_volumetex, loc+vec3(0.0,step[1],0.0) );</span>
<span class="s2">    N[1] = colorToVal(color1) - colorToVal(color2);</span>
<span class="s2">    betterColor = max(max(color1, color2),betterColor);</span>
<span class="s2">    color1 = $sample( u_volumetex, loc+vec3(0.0,0.0,-step[2]) );</span>
<span class="s2">    color2 = $sample( u_volumetex, loc+vec3(0.0,0.0,step[2]) );</span>
<span class="s2">    N[2] = colorToVal(color1) - colorToVal(color2);</span>
<span class="s2">    betterColor = max(max(color1, color2),betterColor);</span>
<span class="s2">    float gm = length(N); // gradient magnitude</span>
<span class="s2">    N = normalize(N);</span>

<span class="s2">    // Flip normal so it points towards viewer</span>
<span class="s2">    float Nselect = float(dot(N,V) &gt; 0.0);</span>
<span class="s2">    N = (2.0*Nselect - 1.0) * N;  // ==  Nselect * N - (1.0-Nselect)*N;</span>

<span class="s2">    // Get color of the texture (albeido)</span>
<span class="s2">    color1 = betterColor;</span>
<span class="s2">    color2 = color1;</span>
<span class="s2">    // todo: parametrise color1_to_color2</span>

<span class="s2">    // Init colors</span>
<span class="s2">    vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);</span>
<span class="s2">    vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);</span>
<span class="s2">    vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);</span>
<span class="s2">    vec4 final_color;</span>

<span class="s2">    // todo: allow multiple light, define lights on viewvox or subscene</span>
<span class="s2">    int nlights = 1;</span>
<span class="s2">    for (int i=0; i&lt;nlights; i++)</span>
<span class="s2">    {{</span>
<span class="s2">        // Get light direction (make sure to prevent zero devision)</span>
<span class="s2">        vec3 L = normalize(view_ray);  //lightDirs[i];</span>
<span class="s2">        float lightEnabled = float( length(L) &gt; 0.0 );</span>
<span class="s2">        L = normalize(L+(1.0-lightEnabled));</span>

<span class="s2">        // Calculate lighting properties</span>
<span class="s2">        float lambertTerm = clamp( dot(N,L), 0.0, 1.0 );</span>
<span class="s2">        vec3 H = normalize(L+V); // Halfway vector</span>
<span class="s2">        float specularTerm = pow( max(dot(H,N),0.0), u_shininess);</span>

<span class="s2">        // Calculate mask</span>
<span class="s2">        float mask1 = lightEnabled;</span>

<span class="s2">        // Calculate colors</span>
<span class="s2">        ambient_color +=  mask1 * u_ambient; // * gl_LightSource[i].ambient;</span>
<span class="s2">        diffuse_color +=  mask1 * lambertTerm;</span>
<span class="s2">        specular_color += mask1 * specularTerm * u_specular;</span>
<span class="s2">    }}</span>

<span class="s2">    // Calculate final color by componing different components</span>
<span class="s2">    final_color = color2 * ( ambient_color + diffuse_color) + specular_color;</span>
<span class="s2">    final_color.a = color2.a;</span>

<span class="s2">    // Done</span>
<span class="s2">    return final_color;</span>
<span class="s2">}}</span>

<span class="s2">// for some reason, this has to be the last function in order for the</span>
<span class="s2">// filters to be inserted in the correct place...</span>

<span class="s2">void main() {{</span>
<span class="s2">    vec3 farpos = v_farpos.xyz / v_farpos.w;</span>
<span class="s2">    vec3 nearpos = v_nearpos.xyz / v_nearpos.w;</span>

<span class="s2">    // Calculate unit vector pointing in the view direction through this</span>
<span class="s2">    // fragment.</span>
<span class="s2">    view_ray = normalize(farpos.xyz - nearpos.xyz);</span>

<span class="s2">    // Compute the distance to the front surface or near clipping plane</span>
<span class="s2">    float distance = dot(nearpos-v_position, view_ray);</span>
<span class="s2">    distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,</span>
<span class="s2">                            (u_shape.x - 0.5 - v_position.x) / view_ray.x));</span>
<span class="s2">    distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,</span>
<span class="s2">                            (u_shape.y - 0.5 - v_position.y) / view_ray.y));</span>
<span class="s2">    distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,</span>
<span class="s2">                            (u_shape.z - 0.5 - v_position.z) / view_ray.z));</span>

<span class="s2">    // Now we have the starting position on the front surface</span>
<span class="s2">    vec3 front = v_position + view_ray * distance;</span>

<span class="s2">    // Decide how many steps to take</span>
<span class="s2">    int nsteps = int(-distance / u_relative_step_size + 0.5);</span>
<span class="s2">    float f_nsteps = float(nsteps);</span>
<span class="s2">    if( nsteps &lt; 1 )</span>
<span class="s2">        discard;</span>

<span class="s2">    // Get starting location and step vector in texture coordinates</span>
<span class="s2">    vec3 step = ((v_position - front) / u_shape) / f_nsteps;</span>
<span class="s2">    vec3 start_loc = front / u_shape;</span>

<span class="s2">    // For testing: show the number of steps. This helps to establish</span>
<span class="s2">    // whether the rays are correctly oriented</span>
<span class="s2">    //gl_FragColor = vec4(0.0, f_nsteps / 3.0 / u_shape.x, 1.0, 1.0);</span>
<span class="s2">    //return;</span>

<span class="s2">    </span><span class="si">{before_loop}</span><span class="s2"></span>

<span class="s2">    // This outer loop seems necessary on some systems for large</span>
<span class="s2">    // datasets. Ugly, but it works ...</span>
<span class="s2">    vec3 loc = start_loc;</span>
<span class="s2">    int iter = 0;</span>
<span class="s2">    while (iter &lt; nsteps) {{</span>
<span class="s2">        for (iter=iter; iter&lt;nsteps; iter++)</span>
<span class="s2">        {{</span>
<span class="s2">            // Get sample color</span>
<span class="s2">            vec4 color = $sample(u_volumetex, loc);</span>
<span class="s2">            float val = color.g;</span>

<span class="s2">            </span><span class="si">{in_loop}</span><span class="s2"></span>

<span class="s2">            // Advance location deeper into the volume</span>
<span class="s2">            loc += step;</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>

<span class="s2">    </span><span class="si">{after_loop}</span><span class="s2"></span>

<span class="s2">    /* Set depth value - from visvis TODO</span>
<span class="s2">    int iter_depth = int(maxi);</span>
<span class="s2">    // Calculate end position in world coordinates</span>
<span class="s2">    vec4 position2 = vertexPosition;</span>
<span class="s2">    position2.xyz += ray*shape*float(iter_depth);</span>
<span class="s2">    // Project to device coordinates and set fragment depth</span>
<span class="s2">    vec4 iproj = gl_ModelViewProjectionMatrix * position2;</span>
<span class="s2">    iproj.z /= iproj.w;</span>
<span class="s2">    gl_FragDepth = (iproj.z+1.0)/2.0;</span>
<span class="s2">    */</span>
<span class="s2">}}</span>


<span class="s2">&quot;&quot;&quot;</span>  <span class="c1"># noqa</span>


<span class="n">MIP_SNIPPETS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">before_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        float maxval = -99999.0; // The maximum encountered value</span>
<span class="s2">        int maxi = 0;  // Where the maximum value was encountered</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">in_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        if( val &gt; maxval ) {</span>
<span class="s2">            maxval = val;</span>
<span class="s2">            maxi = iter;</span>
<span class="s2">        }</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">after_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        // Refine search for max value</span>
<span class="s2">        loc = start_loc + step * (float(maxi) - 0.5);</span>
<span class="s2">        for (int i=0; i&lt;10; i++) {</span>
<span class="s2">            maxval = max(maxval, $sample(u_volumetex, loc).g);</span>
<span class="s2">            loc += step * 0.1;</span>
<span class="s2">        }</span>
<span class="s2">        gl_FragColor = $cmap(maxval);</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">MIP_FRAG_SHADER</span> <span class="o">=</span> <span class="n">FRAG_SHADER</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">MIP_SNIPPETS</span><span class="p">)</span>


<span class="n">TRANSLUCENT_SNIPPETS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">before_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        vec4 integrated_color = vec4(0., 0., 0., 0.);</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">in_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            color = $cmap(val);</span>
<span class="s2">            float a1 = integrated_color.a;</span>
<span class="s2">            float a2 = color.a * (1 - a1);</span>
<span class="s2">            float alpha = max(a1 + a2, 0.001);</span>

<span class="s2">            // Doesn&#39;t work.. GLSL optimizer bug?</span>
<span class="s2">            //integrated_color = (integrated_color * a1 / alpha) +</span>
<span class="s2">            //                   (color * a2 / alpha);</span>
<span class="s2">            // This should be identical but does work correctly:</span>
<span class="s2">            integrated_color *= a1 / alpha;</span>
<span class="s2">            integrated_color += color * a2 / alpha;</span>

<span class="s2">            integrated_color.a = alpha;</span>

<span class="s2">            if( alpha &gt; 0.99 ){</span>
<span class="s2">                // stop integrating if the fragment becomes opaque</span>
<span class="s2">                iter = nsteps;</span>
<span class="s2">            }</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">after_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        gl_FragColor = integrated_color;</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">TRANSLUCENT_FRAG_SHADER</span> <span class="o">=</span> <span class="n">FRAG_SHADER</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">TRANSLUCENT_SNIPPETS</span><span class="p">)</span>


<span class="n">ADDITIVE_SNIPPETS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">before_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        vec4 integrated_color = vec4(0., 0., 0., 0.);</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">in_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        color = $cmap(val);</span>

<span class="s2">        integrated_color = 1.0 - (1.0 - integrated_color) * (1.0 - color);</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">after_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        gl_FragColor = integrated_color;</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ADDITIVE_FRAG_SHADER</span> <span class="o">=</span> <span class="n">FRAG_SHADER</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">ADDITIVE_SNIPPETS</span><span class="p">)</span>


<span class="n">ISO_SNIPPETS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">before_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        vec4 color3 = vec4(0.0);  // final color</span>
<span class="s2">        vec3 dstep = 1.5 / u_shape;  // step to sample derivative</span>
<span class="s2">        gl_FragColor = vec4(0.0);</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">in_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        if (val &gt; u_threshold-0.2) {</span>
<span class="s2">            // Take the last interval in smaller steps</span>
<span class="s2">            vec3 iloc = loc - step;</span>
<span class="s2">            for (int i=0; i&lt;10; i++) {</span>
<span class="s2">                color = $sample(u_volumetex, iloc);</span>
<span class="s2">                if (color.g &gt; u_threshold) {</span>
<span class="s2">                    color = calculateColor(color, iloc, dstep);</span>
<span class="s2">                    gl_FragColor = $cmap(color.g);</span>
<span class="s2">                    iter = nsteps;</span>
<span class="s2">                    break;</span>
<span class="s2">                }</span>
<span class="s2">                iloc += step * 0.1;</span>
<span class="s2">            }</span>
<span class="s2">        }</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">after_loop</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">ISO_FRAG_SHADER</span> <span class="o">=</span> <span class="n">FRAG_SHADER</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">ISO_SNIPPETS</span><span class="p">)</span>

<span class="n">frag_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;mip&#39;</span><span class="p">:</span> <span class="n">MIP_FRAG_SHADER</span><span class="p">,</span>
    <span class="s1">&#39;iso&#39;</span><span class="p">:</span> <span class="n">ISO_FRAG_SHADER</span><span class="p">,</span>
    <span class="s1">&#39;translucent&#39;</span><span class="p">:</span> <span class="n">TRANSLUCENT_FRAG_SHADER</span><span class="p">,</span>
    <span class="s1">&#39;additive&#39;</span><span class="p">:</span> <span class="n">ADDITIVE_FRAG_SHADER</span><span class="p">,</span>
<span class="p">}</span>


<span class="c1"># Custom volume class is needed for better 3D rendering</span>
<div class="viewcode-block" id="Volume"><a class="viewcode-back" href="../../../napari._vispy.html#napari._vispy.volume.Volume">[docs]</a><span class="k">class</span> <span class="nc">Volume</span><span class="p">(</span><span class="n">BaseVolume</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The render method to use</span>

<span class="sd">        Current options are:</span>

<span class="sd">            * translucent: voxel colors are blended along the view ray until</span>
<span class="sd">              the result is opaque.</span>
<span class="sd">            * mip: maxiumum intensity projection. Cast a ray and display the</span>
<span class="sd">              maximum value that was encountered.</span>
<span class="sd">            * additive: voxel colors are added along the view ray until</span>
<span class="sd">              the result is saturated.</span>
<span class="sd">            * iso: isosurface. Cast a ray until a certain threshold is</span>
<span class="sd">              encountered. At that location, lighning calculations are</span>
<span class="sd">              performed to give the visual appearance of a surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span>

    <span class="nd">@method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="c1"># Check and save</span>
        <span class="n">known_methods</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">frag_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">known_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Volume render method should be in </span><span class="si">%r</span><span class="s1">, not </span><span class="si">%r</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">known_methods</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="c1"># Get rid of specific variables - they may become invalid</span>
        <span class="k">if</span> <span class="s1">&#39;u_threshold&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="p">[</span><span class="s1">&#39;u_threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="o">.</span><span class="n">frag</span> <span class="o">=</span> <span class="n">frag_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="o">.</span><span class="n">frag</span><span class="p">[</span><span class="s1">&#39;sampler_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span><span class="o">.</span><span class="n">glsl_sampler_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="o">.</span><span class="n">frag</span><span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span><span class="o">.</span><span class="n">glsl_sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="o">.</span><span class="n">frag</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cmap</span><span class="o">.</span><span class="n">glsl_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_program</span><span class="p">[</span><span class="s1">&#39;texture2D_LUT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">texture_lut</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="p">,</span> <span class="s1">&#39;texture_lut&#39;</span><span class="p">))</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Author

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>